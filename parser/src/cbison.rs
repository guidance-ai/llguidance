#![allow(non_camel_case_types)]

use crate::ffi::{LlgCbisonFactory, LlgMatcher};

pub type cbison_factory_t = &'static LlgCbisonFactory;
pub type cbison_matcher_t = &'static mut LlgMatcher;
pub type CbisonFactory = cbison_factory;

// ---START OF GENERATED CODE---
/* automatically generated by rust-bindgen 0.71.1 */

pub const CBISON_MAGIC: u32 = 464862931;
pub const CBISON_VERSION_MAJOR: u32 = 1;
pub const CBISON_VERSION_MINOR: u32 = 0;
#[doc = " C Binary Interface for Structured Output Negotiation (CBISON)\n\n This represents a factory for matchers, that is specialized\n for a given tokenizer.\n\n We currently do not cover creation APIs for these here."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbison_factory {
    #[doc = " Always CBISON_MAGIC (0x1bb53ed3)"]
    pub magic: u32,
    #[doc = " The value is implementation-specific."]
    pub impl_magic: u32,
    #[doc = " The major version of the API.\n Major version is incremented when the API changes in a\n backward-incompatible way."]
    pub version_major: u32,
    #[doc = " The minor version of the API.\n Minor version is incremented when the API changes in a backward-compatible\n way."]
    pub version_minor: u32,
    #[doc = " The number of tokens in the vocabulary."]
    pub n_vocab: usize,
    #[doc = " The size of token mask in bytes.\n It equals (n_vocab + 31) / 32 * 4."]
    pub mask_byte_len: usize,
    #[doc = " Check if given grammar is valid.\n This is about twice as fast as creating a matcher (which also validates).\n See matcher_new() for the grammar format.\n Returns 0 on success and -1 on error and 1 on warning.\n The error message or warning is written to message, which is message_len\n bytes long. It's always NUL-terminated."]
    pub validate_grammar: ::std::option::Option<
        unsafe extern "C" fn(
            api: cbison_factory_t,
            grammar_type: *const ::std::os::raw::c_char,
            grammar: *const ::std::os::raw::c_char,
            message: *mut ::std::os::raw::c_char,
            message_len: usize,
        ) -> i32,
    >,
    #[doc = " Create a new matcher from the given grammar.\n Always returns a non-null value. Call get_error() on the result\n to check for errors.\n The grammar is of different format, depending on grammar_type:\n - \"regex\" - grammar is regular expression\n - \"json\" or \"json_schema\" - grammar is (stringifed) JSON schema\n - \"json_object\" - equivalent to JSON schema: {\"type\":\"object\"}; grammar is\n ignored\n - \"lark\" - grammar in (a variant of) Lark syntax\n - \"llguidance\" or \"guidance\" - grammar is a list of Lark or JSON schemas in\n JSON format"]
    pub new_matcher: ::std::option::Option<
        unsafe extern "C" fn(
            api: cbison_factory_t,
            grammar_type: *const ::std::os::raw::c_char,
            grammar: *const ::std::os::raw::c_char,
        ) -> cbison_matcher_t,
    >,
    #[doc = " Get the error message from the matcher.\n The error message is always NUL-terminated.\n Returns NULL if there is no error."]
    pub get_error: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Compute the set of allowed tokens for the current state.\n The result is written to mask_dest.\n mask_byte_len must be equal to the one set in this struct.\n Returns 0 on success and -1 on error."]
    pub compute_mask: ::std::option::Option<
        unsafe extern "C" fn(
            matcher: cbison_matcher_t,
            mask_dest: *mut u32,
            mask_byte_len: usize,
        ) -> i32,
    >,
    #[doc = " Advance the matcher by consuming the given tokens.\n Returns 0 on success and -1 on error."]
    pub consume_tokens: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t, tokens: *const u32, n_tokens: usize) -> i32,
    >,
    #[doc = " Check if the grammar can fully accept the input now (ie., if it will allow\n EOS token)."]
    pub is_accepting:
        ::std::option::Option<unsafe extern "C" fn(matcher: cbison_matcher_t) -> bool>,
    #[doc = " Check if the matcher will force EOS token.\n This returns true also in error state, as that is a forced stop."]
    pub is_stopped: ::std::option::Option<unsafe extern "C" fn(matcher: cbison_matcher_t) -> bool>,
    #[doc = " Check how many tokens can be consumed from the given tokens.\n Returns the number of tokens that can be consumed, or -1 on error."]
    pub validate_tokens: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t, tokens: *const u32, n_tokens: usize) -> i32,
    >,
    #[doc = " Compute the fast-forward (forced) tokens for the current state.\n The result is written to output.\n Returns the number of tokens written to output (which can be 0) or -1 on\n error.\n This is optional (can be NULL)."]
    pub compute_ff_tokens: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t, output: *mut u32, output_len: usize) -> i32,
    >,
    #[doc = " Free the matcher."]
    pub free_matcher: ::std::option::Option<unsafe extern "C" fn(matcher: cbison_matcher_t)>,
    #[doc = " Backtracks the matcher states by num_tokens.\n Returns 0 on success and -1 on error.\n This is optional (can be NULL)."]
    pub rollback: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t, num_tokens: usize) -> i32,
    >,
    #[doc = " Resets the matcher to the initial state.\n A matcher in error state cannot be reset.\n Returns 0 on success and -1 on error.\n This is optional (can be NULL)."]
    pub reset: ::std::option::Option<unsafe extern "C" fn(matcher: cbison_matcher_t) -> i32>,
    #[doc = " Clone the matcher.\n This is optional (can be NULL)."]
    pub clone_matcher:
        ::std::option::Option<unsafe extern "C" fn(matcher: cbison_matcher_t) -> cbison_matcher_t>,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cbison_factory"][::std::mem::size_of::<cbison_factory>() - 136usize];
    ["Alignment of cbison_factory"][::std::mem::align_of::<cbison_factory>() - 8usize];
    ["Offset of field: cbison_factory::magic"]
        [::std::mem::offset_of!(cbison_factory, magic) - 0usize];
    ["Offset of field: cbison_factory::impl_magic"]
        [::std::mem::offset_of!(cbison_factory, impl_magic) - 4usize];
    ["Offset of field: cbison_factory::version_major"]
        [::std::mem::offset_of!(cbison_factory, version_major) - 8usize];
    ["Offset of field: cbison_factory::version_minor"]
        [::std::mem::offset_of!(cbison_factory, version_minor) - 12usize];
    ["Offset of field: cbison_factory::n_vocab"]
        [::std::mem::offset_of!(cbison_factory, n_vocab) - 16usize];
    ["Offset of field: cbison_factory::mask_byte_len"]
        [::std::mem::offset_of!(cbison_factory, mask_byte_len) - 24usize];
    ["Offset of field: cbison_factory::validate_grammar"]
        [::std::mem::offset_of!(cbison_factory, validate_grammar) - 32usize];
    ["Offset of field: cbison_factory::new_matcher"]
        [::std::mem::offset_of!(cbison_factory, new_matcher) - 40usize];
    ["Offset of field: cbison_factory::get_error"]
        [::std::mem::offset_of!(cbison_factory, get_error) - 48usize];
    ["Offset of field: cbison_factory::compute_mask"]
        [::std::mem::offset_of!(cbison_factory, compute_mask) - 56usize];
    ["Offset of field: cbison_factory::consume_tokens"]
        [::std::mem::offset_of!(cbison_factory, consume_tokens) - 64usize];
    ["Offset of field: cbison_factory::is_accepting"]
        [::std::mem::offset_of!(cbison_factory, is_accepting) - 72usize];
    ["Offset of field: cbison_factory::is_stopped"]
        [::std::mem::offset_of!(cbison_factory, is_stopped) - 80usize];
    ["Offset of field: cbison_factory::validate_tokens"]
        [::std::mem::offset_of!(cbison_factory, validate_tokens) - 88usize];
    ["Offset of field: cbison_factory::compute_ff_tokens"]
        [::std::mem::offset_of!(cbison_factory, compute_ff_tokens) - 96usize];
    ["Offset of field: cbison_factory::free_matcher"]
        [::std::mem::offset_of!(cbison_factory, free_matcher) - 104usize];
    ["Offset of field: cbison_factory::rollback"]
        [::std::mem::offset_of!(cbison_factory, rollback) - 112usize];
    ["Offset of field: cbison_factory::reset"]
        [::std::mem::offset_of!(cbison_factory, reset) - 120usize];
    ["Offset of field: cbison_factory::clone_matcher"]
        [::std::mem::offset_of!(cbison_factory, clone_matcher) - 128usize];
};
