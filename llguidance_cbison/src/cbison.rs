#![allow(non_camel_case_types)]

use llguidance::ffi::LlgMatcher;

use crate::cb_impl::LlgCbisonFactory;

pub type cbison_factory_t = &'static LlgCbisonFactory;
pub type cbison_matcher_t = &'static mut LlgMatcher;
pub type cbison_matcher_ptr_t = *mut LlgMatcher;

pub type cbison_tokenizer_t = *const CbisonTokenizer;
pub type cbison_tokenizer_ptr_t = *mut CbisonTokenizer;

pub type CbisonFactory = cbison_factory;
pub type CbisonTokenizer = cbison_tokenizer;

// ---START OF GENERATED CODE---
/* automatically generated by rust-bindgen 0.71.1 */

pub const CBISON_FACTORY_MAGIC: u32 = 464862931;
pub const CBISON_FACTORY_VERSION_MAJOR: u32 = 1;
pub const CBISON_FACTORY_VERSION_MINOR: u32 = 0;
pub const CBISON_TOKENIZER_MAGIC: u32 = 4286178104;
pub const CBISON_TOKENIZER_VERSION_MAJOR: u32 = 1;
pub const CBISON_TOKENIZER_VERSION_MINOR: u32 = 0;
#[doc = " Represents a single request for a mask."]
pub type cbison_mask_req_t = cbison_mask_req;
#[doc = " Typically provided by the inference engine to the structured output\n engine."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbison_tokenizer {
    #[doc = " Always CBISON_TOKENIZER_MAGIC (0xff79e338)"]
    pub magic: u32,
    #[doc = " The value is implementation-specific."]
    pub impl_magic: u32,
    #[doc = " The major version of the API.\n Major version is incremented when the API changes in a\n backward-incompatible way."]
    pub version_major: u32,
    #[doc = " The minor version of the API.\n Minor version is incremented when the API changes in a backward-compatible\n way."]
    pub version_minor: u32,
    #[doc = " The number of tokens in the vocabulary."]
    pub n_vocab: usize,
    #[doc = " The id for end-of-sequence token."]
    pub eos_token_id: u32,
    #[doc = " Indicates of the tokenize_bytes() function requires the input bytes\n to be valid UTF-8 (often the case)."]
    pub tokenize_bytes_requires_utf8: bool,
    pub reserved_hd: [u32; 6usize],
    #[doc = " Get bytes for the given token.\n Returns -1 on error (token_id >= n_vocab), and number of bytes in the token\n on success (which can be larger than bytes_len). Writes at most bytes_len\n bytes to bytes; they are *not* NUL-terminated."]
    pub get_token: ::std::option::Option<
        unsafe extern "C" fn(
            api: cbison_tokenizer_t,
            token_id: u32,
            bytes: *mut u8,
            bytes_len: usize,
        ) -> ::std::os::raw::c_int,
    >,
    #[doc = " Returns 0 if the token is a normal text token (e.g. \"hello\", \"\\n\"),\n 1 if the token is a special token (e.g. <|endoftext|>, <|tool|>, etc.).\n and -1 on error (token_id >= n_vocab)."]
    pub is_special_token: ::std::option::Option<
        unsafe extern "C" fn(api: cbison_tokenizer_t, token_id: u32) -> ::std::os::raw::c_int,
    >,
    #[doc = " Tokenize the given bytes and return the tokens.\n Always returns the number of tokens that would be written to output_tokens\n if output_tokens_len was large enough.\n\n This can be omitted, resulting in compute_ff_tokens() always returning an\n empty vector.\n\n If provided, this function must be thread-safe and reentrant."]
    pub tokenize_bytes: ::std::option::Option<
        unsafe extern "C" fn(
            api: cbison_tokenizer_t,
            bytes: *const u8,
            bytes_len: usize,
            output_tokens: *mut u32,
            output_tokens_len: usize,
        ) -> usize,
    >,
    #[doc = " Increment the reference count of the tokenizer.\n All functions allocating tokenizers set the reference count to 1.\n This can be no-op if the tokenizer is never freed."]
    pub incr_ref_count: ::std::option::Option<unsafe extern "C" fn(api: cbison_tokenizer_ptr_t)>,
    #[doc = " Decrement the reference count of the tokenizer.\n If the reference count reaches 0, the tokenizer is freed.\n This can be no-op if the tokenizer is never freed."]
    pub decr_ref_count: ::std::option::Option<unsafe extern "C" fn(api: cbison_tokenizer_ptr_t)>,
    pub reserved_ptr: [*mut ::std::os::raw::c_void; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cbison_tokenizer"][::std::mem::size_of::<cbison_tokenizer>() - 224usize];
    ["Alignment of cbison_tokenizer"][::std::mem::align_of::<cbison_tokenizer>() - 8usize];
    ["Offset of field: cbison_tokenizer::magic"]
        [::std::mem::offset_of!(cbison_tokenizer, magic) - 0usize];
    ["Offset of field: cbison_tokenizer::impl_magic"]
        [::std::mem::offset_of!(cbison_tokenizer, impl_magic) - 4usize];
    ["Offset of field: cbison_tokenizer::version_major"]
        [::std::mem::offset_of!(cbison_tokenizer, version_major) - 8usize];
    ["Offset of field: cbison_tokenizer::version_minor"]
        [::std::mem::offset_of!(cbison_tokenizer, version_minor) - 12usize];
    ["Offset of field: cbison_tokenizer::n_vocab"]
        [::std::mem::offset_of!(cbison_tokenizer, n_vocab) - 16usize];
    ["Offset of field: cbison_tokenizer::eos_token_id"]
        [::std::mem::offset_of!(cbison_tokenizer, eos_token_id) - 24usize];
    ["Offset of field: cbison_tokenizer::tokenize_bytes_requires_utf8"]
        [::std::mem::offset_of!(cbison_tokenizer, tokenize_bytes_requires_utf8) - 28usize];
    ["Offset of field: cbison_tokenizer::reserved_hd"]
        [::std::mem::offset_of!(cbison_tokenizer, reserved_hd) - 32usize];
    ["Offset of field: cbison_tokenizer::get_token"]
        [::std::mem::offset_of!(cbison_tokenizer, get_token) - 56usize];
    ["Offset of field: cbison_tokenizer::is_special_token"]
        [::std::mem::offset_of!(cbison_tokenizer, is_special_token) - 64usize];
    ["Offset of field: cbison_tokenizer::tokenize_bytes"]
        [::std::mem::offset_of!(cbison_tokenizer, tokenize_bytes) - 72usize];
    ["Offset of field: cbison_tokenizer::incr_ref_count"]
        [::std::mem::offset_of!(cbison_tokenizer, incr_ref_count) - 80usize];
    ["Offset of field: cbison_tokenizer::decr_ref_count"]
        [::std::mem::offset_of!(cbison_tokenizer, decr_ref_count) - 88usize];
    ["Offset of field: cbison_tokenizer::reserved_ptr"]
        [::std::mem::offset_of!(cbison_tokenizer, reserved_ptr) - 96usize];
};
#[doc = " C Binary Interface for Structured Output Negotiation (CBISON)\n\n This represents a factory for matchers, that is specialized\n for a given tokenizer.\n\n We currently do not cover creation APIs for these here."]
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct cbison_factory {
    #[doc = " Always CBISON_FACTORY_MAGIC (0x1bb53ed3)"]
    pub magic: u32,
    #[doc = " The value is implementation-specific."]
    pub impl_magic: u32,
    #[doc = " The major version of the API.\n Major version is incremented when the API changes in a\n backward-incompatible way."]
    pub version_major: u32,
    #[doc = " The minor version of the API.\n Minor version is incremented when the API changes in a backward-compatible\n way."]
    pub version_minor: u32,
    #[doc = " The number of tokens in the vocabulary."]
    pub n_vocab: usize,
    #[doc = " The size of token mask in bytes.\n It equals (n_vocab + 31) / 32 * 4."]
    pub mask_byte_len: usize,
    #[doc = " The id for end-of-sequence token."]
    pub eos_token_id: u32,
    pub reserved_hd: [u32; 7usize],
    #[doc = " Free the factory."]
    pub free_factory: ::std::option::Option<unsafe extern "C" fn(api: cbison_factory_t)>,
    #[doc = " Check if given grammar is valid.\n This is about twice as fast as creating a matcher (which also validates).\n See matcher_new() for the grammar format.\n Returns 0 on success and -1 on error and 1 on warning.\n The error message or warning is written to message, which is message_len\n bytes long. It's always NUL-terminated."]
    pub validate_grammar: ::std::option::Option<
        unsafe extern "C" fn(
            api: cbison_factory_t,
            grammar_type: *const ::std::os::raw::c_char,
            grammar: *const ::std::os::raw::c_char,
            message: *mut ::std::os::raw::c_char,
            message_len: usize,
        ) -> i32,
    >,
    #[doc = " Create a new matcher from the given grammar.\n Always returns a non-null value. Call get_error() on the result\n to check for errors.\n The grammar is of different format, depending on grammar_type:\n - \"regex\" - grammar is regular expression\n - \"json\" or \"json_schema\" - grammar is (stringifed) JSON schema\n - \"json_object\" - equivalent to JSON schema: {\"type\":\"object\"}; grammar is\n ignored\n - \"lark\" - grammar in (a variant of) Lark syntax\n - \"llguidance\" or \"guidance\" - grammar is a list of Lark or JSON schemas in\n JSON format"]
    pub new_matcher: ::std::option::Option<
        unsafe extern "C" fn(
            api: cbison_factory_t,
            grammar_type: *const ::std::os::raw::c_char,
            grammar: *const ::std::os::raw::c_char,
        ) -> cbison_matcher_ptr_t,
    >,
    #[doc = " Get the error message from the matcher.\n The error message is always NUL-terminated.\n Returns NULL if there is no error."]
    pub get_error: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t) -> *const ::std::os::raw::c_char,
    >,
    #[doc = " Compute the set of allowed tokens for the current state.\n The result is written to mask_dest.\n mask_byte_len must be equal to the one set in this struct.\n Returns 0 on success and -1 on error."]
    pub compute_mask: ::std::option::Option<
        unsafe extern "C" fn(
            matcher: cbison_matcher_t,
            mask_dest: *mut u32,
            mask_byte_len: usize,
        ) -> i32,
    >,
    #[doc = " Advance the matcher by consuming the given tokens.\n Returns 0 on success and -1 on error."]
    pub consume_tokens: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t, tokens: *const u32, n_tokens: usize) -> i32,
    >,
    #[doc = " Check if the grammar can fully accept the input now (ie., if it will allow\n EOS token)."]
    pub is_accepting:
        ::std::option::Option<unsafe extern "C" fn(matcher: cbison_matcher_t) -> bool>,
    #[doc = " Check if the matcher will force EOS token.\n This returns true also in error state, as that is a forced stop."]
    pub is_stopped: ::std::option::Option<unsafe extern "C" fn(matcher: cbison_matcher_t) -> bool>,
    #[doc = " Check how many tokens can be consumed from the given tokens.\n Returns the number of tokens that can be consumed, or -1 on error."]
    pub validate_tokens: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t, tokens: *const u32, n_tokens: usize) -> i32,
    >,
    #[doc = " Compute the fast-forward (forced) tokens for the current state.\n The result is written to output.\n Returns the number of tokens written to output (which can be 0) or -1 on\n error.\n This is optional (can be NULL)."]
    pub compute_ff_tokens: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t, output: *mut u32, output_len: usize) -> i32,
    >,
    #[doc = " Free the matcher."]
    pub free_matcher: ::std::option::Option<unsafe extern "C" fn(matcher: cbison_matcher_t)>,
    #[doc = " Backtracks the matcher states by num_tokens.\n Returns 0 on success and -1 on error.\n This is optional (can be NULL)."]
    pub rollback: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t, num_tokens: usize) -> i32,
    >,
    #[doc = " Resets the matcher to the initial state.\n A matcher in error state cannot be reset.\n Returns 0 on success and -1 on error.\n This is optional (can be NULL)."]
    pub reset: ::std::option::Option<unsafe extern "C" fn(matcher: cbison_matcher_t) -> i32>,
    #[doc = " Clone the matcher.\n This is optional (can be NULL)."]
    pub clone_matcher: ::std::option::Option<
        unsafe extern "C" fn(matcher: cbison_matcher_t) -> cbison_matcher_ptr_t,
    >,
    #[doc = " Compute masks for a number of matchers.\n The masks can be computed in parallel, and the function returns only\n when all of them are computed.\n The behavior is undefined if any matcher is specified more than once,\n or if other operations are performed on the matchers while this function is\n running.\n This is optional (can be NULL)."]
    pub compute_masks: ::std::option::Option<
        unsafe extern "C" fn(
            api: cbison_factory_t,
            reqs: *mut cbison_mask_req_t,
            n_reqs: usize,
        ) -> i32,
    >,
    pub reserved_ptr: [*mut ::std::os::raw::c_void; 16usize],
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cbison_factory"][::std::mem::size_of::<cbison_factory>() - 312usize];
    ["Alignment of cbison_factory"][::std::mem::align_of::<cbison_factory>() - 8usize];
    ["Offset of field: cbison_factory::magic"]
        [::std::mem::offset_of!(cbison_factory, magic) - 0usize];
    ["Offset of field: cbison_factory::impl_magic"]
        [::std::mem::offset_of!(cbison_factory, impl_magic) - 4usize];
    ["Offset of field: cbison_factory::version_major"]
        [::std::mem::offset_of!(cbison_factory, version_major) - 8usize];
    ["Offset of field: cbison_factory::version_minor"]
        [::std::mem::offset_of!(cbison_factory, version_minor) - 12usize];
    ["Offset of field: cbison_factory::n_vocab"]
        [::std::mem::offset_of!(cbison_factory, n_vocab) - 16usize];
    ["Offset of field: cbison_factory::mask_byte_len"]
        [::std::mem::offset_of!(cbison_factory, mask_byte_len) - 24usize];
    ["Offset of field: cbison_factory::eos_token_id"]
        [::std::mem::offset_of!(cbison_factory, eos_token_id) - 32usize];
    ["Offset of field: cbison_factory::reserved_hd"]
        [::std::mem::offset_of!(cbison_factory, reserved_hd) - 36usize];
    ["Offset of field: cbison_factory::free_factory"]
        [::std::mem::offset_of!(cbison_factory, free_factory) - 64usize];
    ["Offset of field: cbison_factory::validate_grammar"]
        [::std::mem::offset_of!(cbison_factory, validate_grammar) - 72usize];
    ["Offset of field: cbison_factory::new_matcher"]
        [::std::mem::offset_of!(cbison_factory, new_matcher) - 80usize];
    ["Offset of field: cbison_factory::get_error"]
        [::std::mem::offset_of!(cbison_factory, get_error) - 88usize];
    ["Offset of field: cbison_factory::compute_mask"]
        [::std::mem::offset_of!(cbison_factory, compute_mask) - 96usize];
    ["Offset of field: cbison_factory::consume_tokens"]
        [::std::mem::offset_of!(cbison_factory, consume_tokens) - 104usize];
    ["Offset of field: cbison_factory::is_accepting"]
        [::std::mem::offset_of!(cbison_factory, is_accepting) - 112usize];
    ["Offset of field: cbison_factory::is_stopped"]
        [::std::mem::offset_of!(cbison_factory, is_stopped) - 120usize];
    ["Offset of field: cbison_factory::validate_tokens"]
        [::std::mem::offset_of!(cbison_factory, validate_tokens) - 128usize];
    ["Offset of field: cbison_factory::compute_ff_tokens"]
        [::std::mem::offset_of!(cbison_factory, compute_ff_tokens) - 136usize];
    ["Offset of field: cbison_factory::free_matcher"]
        [::std::mem::offset_of!(cbison_factory, free_matcher) - 144usize];
    ["Offset of field: cbison_factory::rollback"]
        [::std::mem::offset_of!(cbison_factory, rollback) - 152usize];
    ["Offset of field: cbison_factory::reset"]
        [::std::mem::offset_of!(cbison_factory, reset) - 160usize];
    ["Offset of field: cbison_factory::clone_matcher"]
        [::std::mem::offset_of!(cbison_factory, clone_matcher) - 168usize];
    ["Offset of field: cbison_factory::compute_masks"]
        [::std::mem::offset_of!(cbison_factory, compute_masks) - 176usize];
    ["Offset of field: cbison_factory::reserved_ptr"]
        [::std::mem::offset_of!(cbison_factory, reserved_ptr) - 184usize];
};
#[doc = " Represents a single request for a mask."]
#[repr(C)]
pub struct cbison_mask_req {
    #[doc = " The matcher to compute the mask for."]
    pub matcher: cbison_matcher_ptr_t,
    #[doc = " Where to write the mask.\n This must point to a buffer of size mask_byte_len bytes."]
    pub mask_dest: *mut u32,
}
#[allow(clippy::unnecessary_operation, clippy::identity_op)]
const _: () = {
    ["Size of cbison_mask_req"][::std::mem::size_of::<cbison_mask_req>() - 16usize];
    ["Alignment of cbison_mask_req"][::std::mem::align_of::<cbison_mask_req>() - 8usize];
    ["Offset of field: cbison_mask_req::matcher"]
        [::std::mem::offset_of!(cbison_mask_req, matcher) - 0usize];
    ["Offset of field: cbison_mask_req::mask_dest"]
        [::std::mem::offset_of!(cbison_mask_req, mask_dest) - 8usize];
};
